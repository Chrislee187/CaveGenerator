using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using UnityEngine;
using Debug = UnityEngine.Debug;

[ExecuteInEditMode]
public class CaveBuilder : MonoBehaviour
{
    #region Settings
    [Header("Map size settings")]
    [Tooltip("Changing the map size will effectively generate a new random map, even when using " +
             "the same seed. The seed is honoured and the same sequence of random numbers will be generated but they are now in different places " +
             "on the newly sized map")]
    [Min(1)]
    public int Width = 128;

    [Tooltip("Changing the map size will effectively generate a new random map, even when using " +
             "the same seed. The seed is honoured and the same sequence of random numbers will be generated but they are now in different places " +
             "on the newly sized map")]
    [Min(1)]
    public int Height = 128;

    [Header("Randomisation settings")]
    [Tooltip("When the random number (between 0-100) in floor plan creation is LESS THAN this value a wall will be placed, otherwise the cell is empty.")]
    [Range(0 ,100)]
    public int InitialMapFillPercent = 50;

    [Tooltip("Seed to use to initialise the random number generator")]
    public string Seed = "";

    [Tooltip("Use a random seed each time the map is generated")]
    public bool UseRandomSeed;

    [Header("Smoothing and Border settings")]
    [Tooltip("Size in squares of the border to add around the edge of the floor map. NB. This is added to the specified width and height of the map and is in addition to the single square wall that " +
             "is automatically inserted around the inner border of the map to ensure small wall/room thresholds work in correctly around the edges of the map.")]
    [Min(0)]
    public int BorderSize = 1;

    [Tooltip("Number of times to apply the Smoothing algorithm on the initial randomised map data.")]
    [Range(0,25)]
    public int SmoothingIterations = 5;

    [Header("Region Settings")]
    [Tooltip("Use to remove small wall 'islands' and small rooms")]
    public bool ProcessRegions = true;

    [Min(0)]
    [Tooltip("When processing regions, remove walls with less than this number of nodes. This removes any small 'islands' in the middle or larger open spaces")]
    public int SmallWallThresholdSize = 25;

    [Min(0)]
    [Tooltip("When processing regions, remove and wall outlines with less than this number of nodes. This removes any small rooms.")]
    public int SmallRoomThresholdSize = 25;

    [Tooltip("Creates passages between rooms at there closest points to ensure that all rooms are " +
             "directly or indirectly connected to each other.")]
    public bool EnsureAllRoomsConnected = true;

    [Min(1)]
    [Tooltip("Interconnecting passage radius - Passages are generated by clearing a circle of squares around the centre of the passage path.")]
    public int PassageRadius = 1;


    [Header("Mesh Settings")]
    [Tooltip("Generate the inverse floor plan mesh (inverse because we are generating the floor plan by generating the walls, floor is the areas NOT covered by walls")]
    public bool GenerateFloorPlanMesh = true;
    [Tooltip("Generate a vertical mesh for the walls, to use the cave in 3D")]
    public bool GenerateWallMesh = true;

    #endregion

    private string _lastSeed = "";
    private bool _gizmosDrawMap;

    private GameObject _cave;
    private GameObject _walls;

    private int[,] _map;
    private FloorPlanMeshCreator _floorPlanMeshCreator;

    private void Start()
    {
#if UNITY_EDITOR
        GenerateCave();
#endif
    }

    [ContextMenu("Generate New Cave")]
    public void GenerateCave()
    {
        var floorPlanGenerator = new CaveMapGenerator(Width, Height);

        var caveSettings = GetSettings();

        if (UseRandomSeed)
        {
            caveSettings.Seed = System.Guid.NewGuid().ToString();
        }

        _map = floorPlanGenerator.Generate(caveSettings);

        Seed = floorPlanGenerator.Seed;
        _lastSeed = Seed;


        if (!GenerateWallMesh && !GenerateFloorPlanMesh)
        {
            _gizmosDrawMap = true;

            if (_cave != null) _cave.SetActive(false);
            if (_walls != null) _walls.SetActive(false);
        }
        else
        {
            _gizmosDrawMap = false;
            GenerateMeshes(_map, 1f);
        }
    }

    private GameObject BuildContainerObject(string contentsName, Color defaultMeshColour)
    {
        var c = defaultMeshColour;
        var o = CreateMeshContainer(contentsName, c);
        o.AddComponent<MeshFilter>();
        return o;
    }

    private void GenerateMeshes(int[,] map, float squareSize)
    {
        var marchingSquares = new MarchingSquaresMeshData(map, squareSize);

        if (_cave == null)
        {
            var c = new Color(103 / 255f, 79 / 255f, 79 / 255f);
            _cave = BuildContainerObject("Cave", c);
        }

        var caveFilter = _cave.GetComponent<MeshFilter>();
        if (GenerateFloorPlanMesh)
        {
            _floorPlanMeshCreator = new FloorPlanMeshCreator(marchingSquares);
            caveFilter.sharedMesh = _floorPlanMeshCreator.Create();
        }
        _cave.gameObject.SetActive(GenerateFloorPlanMesh);


        if (_walls == null)
        {
            var c = new Color(103 / 255f, 0, 0);
            _walls = BuildContainerObject("Walls", c);
        }

        var wallFilter = _walls.GetComponent<MeshFilter>();
        if (GenerateWallMesh)
        {
            wallFilter.mesh = new WallMeshCreator(marchingSquares).Create();
        }
        _walls.gameObject.SetActive(GenerateWallMesh);
    }

    private GameObject CreateMeshContainer(string contentsName, Color color)
    {
        var container = new GameObject(contentsName);
        container.transform.parent = transform;

        var mr = container.AddComponent<MeshRenderer>();

        mr.materials = new[]
        {
            new Material(Shader.Find("Standard"))
            {
                name = contentsName, 
                color = color
            }
        };

        return container;
    }

    private CaveSettings GetSettings()
    {
        var caveSettings = new CaveSettings(
            Seed,
            InitialMapFillPercent,
            BorderSize,
            SmoothingIterations,
            ProcessRegions,
            SmallWallThresholdSize,
            SmallRoomThresholdSize,
            EnsureAllRoomsConnected,
            PassageRadius);
        return caveSettings;
    }

    #region Editor
#if UNITY_EDITOR

    [ContextMenu("Map Generation Performance Test")]
    public void PerfTest()
    {
        var sw = new Stopwatch();
        var avgs = new List<long>();
        for (var i = 0; i < 10; i++)
        {
            sw.Start();

            GenerateCave();

            sw.Stop();
            avgs.Add(sw.ElapsedMilliseconds);
            sw.Reset();
        }
        Debug.Log($"10 Generations took an average of {avgs.Average()}ms");
    }

    private void OnValidate()
    {
        if (GUI.changed)
        {
            if (Seed == _lastSeed && UseRandomSeed)
            {
                UseRandomSeed = false;
                GenerateCave();
                UseRandomSeed = true;
            }
            else
            {
                GenerateCave();
            }
        }

    }

    private void OnDrawGizmos()
    {
        if (_map != null && _gizmosDrawMap)
        {
            var width = _map.GetUpperBound(0);
            var height = _map.GetUpperBound(1);
            for (var x = 0; x < width; x++)
            {
                for (var y = 0; y < height; y++)
                {
                    Gizmos.color = (_map[x, y] == 1) ? Color.black : Color.white;
                    var pos = new Vector3(-width / 2 + x + .5f, 0, -height / 2 + y + .5f);
                    Gizmos.DrawCube(pos, Vector3.one);
                }
            }
        }
    }

#endif

    #endregion
}
